# Лабораторная работа №3

### Задание 
Написать простейший компилятор на базе LLVM для простейшего языка, который содержит следующее:
- 2-3 арифметические операции с присвоением результата переменной
- 2-3 структуры управления (например, цикл for, инструкция if)
- целочисленный тип
- передача целочисленного результата через return в функции main (в программе только одна функция)

Простейший компилятор должен печатать LLVM-код на консоль.

### Запуск

```cmd
./build.sh
./a.out input.txt
```

### Что происходит

Имеем грамматику, которая описывается в этой проге. Пример программы на этой грамматике лежит в input.txt.

Процесс выполнения
- Программа запускается с одним аргументом командной строки - именем входного файла.
- Файл считывается в строку input_seq.
- Вызывается initialize_module() для создания LLVM контекста, модуля и построителя инструкций.
- Parse() парсит входной код, создавая AST.
- codegen() в AST функции генерирует LLVM IR для функции.
- Сгенерированный модуль LLVM выводится на стандартный поток ошибок.

Определения использованных структур
- LLVMContext: Управляет всеми уникальными данными, которые могут быть связаны с LLVM IR, такими как таблицы имен и типов.
- Module: Представляет собой набор связанных между собой функций, глобальных переменных и т.д.
- IRBuilder<>: Помогает в создании LLVM IR инструкций с помощью более высокого уровня абстракции.
- AllocaInst: Инструкция, которая выделяет память на стеке в начале функции.
- Function: Представляет собой функцию в LLVM IR.
- BasicBlock: Представляет собой блок кода, который всегда выполняется последовательно от начала до конца.
- Value: Базовый класс для всех LLVM IR значений.
- ConstantInt: Представляет собой константное целое число.
- APInt: Класс для представления целых чисел произвольной точности.
- FunctionType: Представляет собой тип функции в LLVM IR.
- verifyFunction: Функция для верификации правильности функции LLVM IR.
- Constant: Базовый класс для всех констант в LLVM IR.
- Type: Базовый класс для всех типов данных в LLVM IR.
- FunctionAST: Класс, представляющий функцию в AST.
- PrototypeAST: Класс, представляющий прототип функции в AST.
- ExprAST: Базовый класс для всех выражений в AST.
- NumberExprAST: Класс, представляющий числовое выражение в AST.
- VariableExprAST: Класс, представляющий переменную в AST.
- BinaryExprAST: Класс, представляющий бинарное выражение в AST.
- IfExprAST: Класс, представляющий условное выражение в AST.
- ForExprAST: Класс, представляющий цикл for в AST.

Этот код демонстрирует основы создания простого компилятора с использованием LLVM для генерации кода. Он парсит входной код, создает AST, затем обходит AST, генерируя LLVM IR, который затем можно транслировать в машинный код или другой низкоуровневый формат.



Методы `codegen()` в классах `ExprAST` предназначены для генерации LLVM-инструкций, которые выполняют вычисление значения выражения, представленного данным узлом AST.

1. Метод `codegen()` в классе `NumberExprAST` просто возвращает `ConstantInt::get(*context, APInt(32, Val, false))`, где `Val` - это значение числового токена, которое было сохранено при создании объекта `NumberExprAST`. Это создает LLVM-константу со значением `Val` типа `int32_t`.

2. Метод `codegen()` в классе `VariableExprAST` загружает значение переменной из памяти. Сначала создается `AllocaInst* A` - указатель на выделенную область памяти для переменной. Если переменная уже была выделена ранее, то указатель на нее сохраняется в `named_values`, и в этом случае просто возвращается значение `A`. Если переменная не была выделена ранее, то вызывается функция `CreateEntryBlockAlloca()` для выделения области памяти в функции `TheFunction` и сохранения указателя на нее в `named_values`. Затем вызывается `builder->CreateLoad()` для загрузки значения переменной из памяти и возвращения его.

3. Метод `codegen()` в классе `BinaryExprAST` генерирует LLVM-инструкции для выполнения операции над двумя операндами. Сначала вызывается `LHS->codegen()` и `RHS->codegen()` для получения значений левого и правого операндов. Затем, в зависимости от оператора (`Op`), вызывается одна из функций `builder->CreateAdd()`, `builder->CreateSub()` и т.д. для создания инструкции, которая выполняет операцию над операндами. Результат сохраняется в новый объект `BinaryExprAST` и возвращается.

4. Метод `codegen()` в классе `IfExprAST` генерирует LLVM-инструкции для выполнения конструкции `if-else`. Сначала вызывается `Cond->codegen()` для получения значения условия. Затем вызывается `builder->CreateCondBr()` для создания условного перехода на блок `ThenBB`, если условие истинно, и на блок `ElseBB`, если условие ложно. Затем вызывается `builder->SetInsertPoint()` для установки точки вставки на блок `ThenBB`. Затем вызывается цикл `for(auto &expr : Then)` для выполнения всех выражений в блоке `Then`. Затем вызывается `builder->CreateBr()` для перехода на блок `MergeBB`. Аналогичные действия выполняются для блока `Else`. В конце вызывается `builder->CreateRet()` для возврата значения из функции.

5. Метод `codegen()` в классе `ForExprAST` генерирует LLVM-инструкции для выполнения конструкции `for`. Сначала вызывается `Start->codegen()` для получения значения начального выражения. Затем вызывается `builder->CreateBr()` для перехода на блок `LoopBB`. Затем вызывается `builder->SetInsertPoint()` для установки точки вставки на блок `LoopBB`. Затем вызывается цикл `for(auto &expr : Body)` для выполнения всех выражений в теле цикла. Затем вызывается `builder->CreateCondBr()` для проверки условия цикла и перехода на блок `LoopBB` или на блок `AfterBB`. Затем вызывается `builder->SetInsertPoint()` для установки точки вставки на блок `AfterBB`.

6. Метод `codegen()` в классе `FunctionAST` генерирует LLVM-инструкции для функции. Сначала вызывается `proto->codegen()` для создания типа функции. Затем вызывается `Function::Create()` для создания функции с заданным типом. Затем вызывается `named_values.clear()` для очистки словаря именованных переменных. Затем вызывается цикл `for(auto &Arg : TheFunction->args())` для именования всех параметров функции. Затем вызывается `builder->CreateRet()` для возврата значения из функции. Затем вызывается `verifyFunction(*TheFunction)` для проверки корректности синтаксиса функции. В конце возвращается указатель на созданную функцию.

Таким образом, методы `codegen()` в классах `ExprAST` позволяют генерировать LLVM-инструкции для вычисления выражений, представленных узлами AST, и создавать функции на основе этих выражений.

